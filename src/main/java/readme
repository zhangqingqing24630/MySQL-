TM:维护 XID 文件,并提供接口供其他模块来查询某个事务的状态。
    格式：事务的个数(8个字节) | 事务 xid 的状态，第xid个事务就存在 (xid-1)+8 处，xid-1，是因为
    xid0（可以没有申请事务的情况下进行）不需要记录
    事务状态：active，正在进行，尚未结束
            committed，已提交
            aborted，已撤销（回滚）
    RandomAccessFile 用来记录事务id 的文件，最大的好处是有一个指针，可以指示当前文件读取的位置

DM 管理数据库 DB 文件和日志文件
    1) 分页管理 DB 文件，并进行缓存；
    2) 管理日志文件，保证在发生错误时可以根据日志进行恢复；
    3) 抽象 DB 文件为 DataItem 供上层模块使用，并提供缓存。
    上层模块和文件系统之间的一个抽象层，向下直接读写文件，向上提供数据的包装；另外就是日志功能。
    可以注意到，无论是向上还是向下，DM 都提供了一个缓存的功能，用内存操作来保证效率

    缓存框架（map）:引用计数框架  当引用归零时，缓存就会驱逐这个资源。
        private HashMap<Long, T> cache;                     // 缓存里的数据
        private HashMap<Long, Integer> references;          // 资源的引用个数
        private HashMap<Long, Boolean> getting;             // 正在从数据源被获取的资源
        //通过cache.get()获取数据要向判断getting.get()里面有无被其他线程从数据源请求数据，有，等待，
        无，判断缓存中有无这个资源，有从缓存中拿，引用加1，无，在getting中注册，从数据库中拿。

      问题的根源还是，LRU 策略中，资源驱逐不可控，上层模块无法感知。
      而引用计数策略正好解决了这个问题，只有上层模块主动释放引用，缓存在确保没有模块在使用这个资源了，才会去驱逐资源。

      共享内存数组：对数组进行切片是同一块内存，但Java执行类似 subArray(子数组) 的操作时，
      只会在底层进行一个复制，无法同一片内存
      比如array2 := array1[5:]，要求array2和array1的第5个数开始要共享同一片内存
        但引用为0或者安全关闭时，会强制回源

      数据页的管理page
        根据页号算偏移，然后从偏移开始存数据的大小

        PageOne数据库文件的 的第一页，用来做启动检查。具体的原理是，
        在每次数据库启动时，会生成一串随机字节，存储在 100 ~ 107 字节。
        在数据库正常关闭时，会将这串字节，拷贝到第一页的 108 ~ 115 字节。
        这样数据库在每次启动时，就会检查第一页两处的字节是否相同，
        以此来判断上一次是否正常关闭。如果是异常关闭，就需要执行数据的恢复流程
        PageX 每一页的开头两个字符表示该页的偏移（写到哪儿了），每次写入都会在开头更新
      日志管理
        日志文件标准格式为：只有一页，每次都要遍历每个日志的长度读取
         * [XChecksum] [Log1] [Log2] ... [LogN] [BadTail]
        每条正确日志的格式为：
          * [Size] [Checksum] [Data]

    日志的恢复策略（两种日志 更新日志 插入日志）
        在进行 插入 和 更新 操作之前，必须先进行对应的日志操作，在保证日志写入磁盘后，才进行数据操作。
        形式：   重做所有崩溃时已完成（committed 或 aborted）的事务
                撤销所有崩溃时未完成（active）的事务
        多线程下保证
        规定1：正在进行的事务，不会读取其他任何未提交的事务产生的数据。
        规定2：正在进行的事务，不会修改其他任何未提交的事务修改或产生的数据。

    页面索引
        将一页的空间划分成了 40 个区间。在启动时，就会遍历所有的页面信息，获取页面的空闲空间，
        insert 在请求一个页时，会首先将所需的空间向上取整，映射到某一个区间，
        随后取出满足这个区间空间的任何一页（防止并发写），写完后再重写插入到页面中

VM
    MYDB 通过 MVCC，降低了事务的阻塞概率。譬如，T1 想要更新记录 X 的值，
    于是 T1 需要首先获取 X 的锁，接着更新，也就是创建了一个新的 X 的版本，假设为 x3。
    假设 T1 还没有释放 X 的锁时，T2 想要读取 X 的值，这时候就不会阻塞，MYDB 会返回一个较老版本的 X，
    例如 x2。这样最后执行的结果，就等价于，T2 先执行，T1 后执行，调度序列依然是可串行化的。
    如果 X 没有一个更老的版本，那只能等待 T1 释放锁了。所以只是降低了概率。

    VM向上层抽象出entry
    VM 并没有提供 Update 操作，对于字段的更新操作由后面的表和字段管理（TBM）实现。
    所以在 VM 的实现中，一条记录只有一个版本
         * entry结构：
         * [XMIN] [XMAX] [data]
         *  XMIN 应当在版本创建时填写，
         *  XMAX 则在版本被删除，或者有新版本出现时填写。
         *  更新操作由后面的表和字段管理（TBM）实现
    读已提交：事务在读取数据时, 只能读取已经提交事务产生的数据。
    (XMIN == Ti and                             // 由Ti创建且
        XMAX == NULL                            // 还未被删除
    )or
    (XMIN is commited and                       // 由一个已提交的事务创建且
        (XMAX == NULL or                        // 尚未删除或
        (XMAX != Ti and XMAX is not commited)   // 由一个未提交的事务删除
    ))
    获取 Ti 适合的版本，只需要从最新版本开始，依次向前检查可见性，如果为 true，就可以直接返回。

    可重复读
        不可重复度，T1 在第二次读取的时候，读到了已经提交的 T2 修改的值
    事务只能读取它开始时, 就已经结束的那些事务产生的数据版本
    这条规定，增加于，事务需要忽略：
        在本事务后开始的事务的数据;
        本事务开始时还是 active 状态的事务的数据
    (XMIN == Ti and                 // 由Ti创建且
     (XMAX == NULL or               // 尚未被删除
    ))
    or                              // 或
    (XMIN is commited and           // 由一个已提交的事务创建且
     XMIN < XID and                 // 这个事务小于Ti且
     XMIN is not in SP(Ti) and      // 这个事务在Ti开始前提交且
     (XMAX == NULL or               // 尚未被删除或
      (XMAX != Ti and               // 由其他事务删除但是
       (XMAX is not commited or     // 这个事务尚未提交或
    XMAX > Ti or                    // 这个事务在Ti开始之后才开始或
    XMAX is in SP(Ti)               // 这个事务在Ti开始前还未提交
    ))))

当前活跃的所有事务 SP(Ti)

版本跳跃问题 解决MVCC问题
    T1 将 X 从 x0 更新为了 x1，这是没错的。但是 T2 则是将 X 从 x0 更新成了 x2，跳过了 x1 版本。
解决版本跳跃的思路：如果 Ti 需要修改 X，而 X 已经被 Ti 不可见的事务 Tj 修改了，
那么要求 Ti 回滚。

Ti 不可见的 Tj，有两种情况：
XID(Tj) > XID(Ti)
Tj in SP(Ti)

死锁检测
    上一节提到了 2PL 会阻塞事务，直至持有锁的线程释放锁。可以将这种等待关系抽象成有向边，
    例如 Tj 在等待 Ti，就可以表示为 Tj --> Ti。这样，
    无数有向边就可以形成一个图（不一定是连通图）。检测死锁也就简单了，只需要查看这个图中是否有环即可




– DM: insert(x), update(x), read(x)
DM提供了针对数据项(data item)的基本插入, 更新, 读取操作, 且这些操作是原子性的. DM会直接对数据库文件进行读写.
– TM: begin, commit(T), abort(T), isActive(T),isCommitted(T),isAborted(T)
TM提供了针对事务的开始, 提交, 回滚操作, 同时提供了对数据项状态的查询操作.
– VM: insert(X), update(X), read(X), delete(X)
VM提供了针对记录(entry)的增删查改操作, VM在内部为每条记录维护多个版本, 并根据不同的事务, 返回不同的版本. VM对这些实现, 是建立在DM和TM的各个操作上的，还有一个事务可见性类Visibility。
– TBM: execute(statement)
TBM就是非常高层的模块了, 他能直接执行用户输入的语句(statement), 然后进行执行. TBM对语句的执行是建立在VM和IM提供的各个操作上的.
– IM: value search(key), insert(key, value)
IM提供了对索引的基本操作.